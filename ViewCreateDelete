#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <iostream>
#include <string>
//#include "TerminateProcess.h"

using namespace std;


static ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;
static int numProcessors;
static HANDLE self;

void start(DWORD processID) {

	SYSTEM_INFO sysInfo;
	FILETIME ftime, fsys, fuser;

	GetSystemInfo(&sysInfo);
	numProcessors = sysInfo.dwNumberOfProcessors;

	GetSystemTimeAsFileTime(&ftime);
	memcpy(&lastCPU, &ftime, sizeof(FILETIME));

	self = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID); ;
	GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
	memcpy(&lastSysCPU, &fsys, sizeof(FILETIME));
	memcpy(&lastUserCPU, &fuser, sizeof(FILETIME));
}

double getCurrentValue() {
	FILETIME ftime, fsys, fuser;
	ULARGE_INTEGER now, sys, user;
	double percent;

	GetSystemTimeAsFileTime(&ftime);
	memcpy(&now, &ftime, sizeof(FILETIME));

	GetProcessTimes(self, &ftime, &ftime, &fsys, &fuser);
	memcpy(&sys, &fsys, sizeof(FILETIME));
	memcpy(&user, &fuser, sizeof(FILETIME));
	percent = (sys.QuadPart - lastSysCPU.QuadPart) +
		(user.QuadPart - lastUserCPU.QuadPart);
	percent /= (now.QuadPart - lastCPU.QuadPart);
	percent /= numProcessors;
	lastCPU = now;
	lastUserCPU = user;
	lastSysCPU = sys;

	return percent * 100;
}

void memoryInfor(DWORD processID)
{
	HANDLE tmpHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);   //open process
	MEMORYSTATUSEX memInfo;
	memInfo.dwLength = sizeof(MEMORYSTATUSEX);
	GlobalMemoryStatusEx(&memInfo);
	DWORDLONG totalVirtualMem = memInfo.ullTotalPageFile;
	PROCESS_MEMORY_COUNTERS pmc;
	GetProcessMemoryInfo(tmpHandle, &pmc, sizeof(pmc));
	//SIZE_T virtualMemUsedByMe = pmc.PrivateUsage;
	DWORDLONG totalPhysMem = memInfo.ullTotalPhys;
	//cout << totalPhysMem;
	SIZE_T physMemUsedByMe = pmc.WorkingSetSize;
	cout << "Memory used is " << physMemUsedByMe * 0.000000125 << "Mb" << endl;


	/*double start = get_cpu_time(processID);
	double end;
	//system("Bla.exe");
	end = get_cpu_time(processID);

	printf("Took %f seconds of CPU time\n", end - start);

	//std::cin.get();
	*/
	start(processID);
	printf("CPU usage is %lf\n", getCurrentValue());
	


}

void Terminate(DWORD processID)
{
	HANDLE tmpHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);   //open process
	if (NULL != tmpHandle)
	{
		TerminateProcess(tmpHandle, 0); //terminate opened process
	}
	CloseHandle(tmpHandle);
}

void PrintProcessNameAndID(DWORD processID)
{
	TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID);

	if (NULL != hProcess)
	{
		HMODULE hMod;
		DWORD cbNeeded;

		if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
			&cbNeeded))   //extract information , Retrieves a handle for each module in the specified process
		{
			GetModuleBaseName(hProcess, hMod, szProcessName,
				sizeof(szProcessName) / sizeof(TCHAR));     //get process name and store in szprocessname
		}
	}

	_tprintf(TEXT("\n%s  (PID: %u)\n"), szProcessName, processID);

	CloseHandle(hProcess);
}

int main(int argc, TCHAR* argv[])
{
	cout << " 1: view all process\n 2: To start a new process\n 3: To terminate a process from listed\n";

	while (1)
	{
		int getOption;
		cout << "\nChoose your option : ";
		cin >> getOption;

		switch (getOption)
		{
		case 1:
		{
			DWORD aProcesses[1024], cbNeeded, cProcesses;
			unsigned int i;
			if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))   //to get all the process ID
			{
				return 1;
			}
			cProcesses = cbNeeded / sizeof(DWORD);
			for (i = 0; i < cProcesses; i++)
			{
				if (aProcesses[i] != 0)
				{
					PrintProcessNameAndID(aProcesses[i]);    //get process name
					memoryInfor(aProcesses[i]);
				}
			}

			break;
		}
		case 2:
		{

		std:string s;
			cout << "Enter the process name : ";
			cin >> s;
			std::wstring ws;
			ws.assign(s.begin(), s.end());
			LPWSTR pwst = &ws[0];
			LPCWSTR pcwstr = ws.c_str();
			ShellExecute(0, L"open", pcwstr, NULL, 0, SW_SHOW);
			break;
		}
		case 3:
		{
			cout << "Enter the process ID to be deleted : ";
			DWORD processID;
			cin >> processID;
			Terminate(processID);
			break;
		}

		}


	}

	return 0;
}
