#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <iostream>
#include <string>
//#include "TerminateProcess.h"

using namespace std;


double get_cpu_time(DWORD processID) {
	HANDLE tmpHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);
	FILETIME a, b, c, d;
	if (GetProcessTimes(tmpHandle, &a, &b, &c, &d) != 0) {
		//  Returns total user time.
		//  Can be tweaked to include kernel times as well.
		return
			(double)(d.dwLowDateTime |
			((unsigned long long)d.dwHighDateTime << 32)) * 0.0000001;
	}
	else {
		//  Handle error
		return 0;
	}
}


void memoryInfor(DWORD processID)
{
	HANDLE tmpHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);   //open process
	MEMORYSTATUSEX memInfo;
	memInfo.dwLength = sizeof(MEMORYSTATUSEX);
	GlobalMemoryStatusEx(&memInfo);
	DWORDLONG totalVirtualMem = memInfo.ullTotalPageFile;
	PROCESS_MEMORY_COUNTERS pmc;
	GetProcessMemoryInfo(tmpHandle, &pmc, sizeof(pmc));
	//SIZE_T virtualMemUsedByMe = pmc.PrivateUsage;
	DWORDLONG totalPhysMem = memInfo.ullTotalPhys;
	//cout << totalPhysMem;
	SIZE_T physMemUsedByMe = pmc.WorkingSetSize;
	cout <<"Memory used is "<< physMemUsedByMe* 0.000000125 <<"Mb"<<endl;


	/*double start = get_cpu_time(processID);
	double end;
	//system("Bla.exe");
	end = get_cpu_time(processID);

	printf("Took %f seconds of CPU time\n", end - start);

	//std::cin.get();
	*/

	DWORD   dwThreadId;
	HANDLE  hThread;

	int startcputime, endcputime, wcts, wcte;

	startcputime = get_cpu_time(processID);

	
	WaitForSingleObject(tmpHandle, INFINITE);

	endcputime = get_cpu_time(processID);

	std::cout << "it took " << endcputime - startcputime << " s of CPU to execute this\n";



}

void Terminate(DWORD processID)
{
	HANDLE tmpHandle = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);   //open process
	if (NULL != tmpHandle) 
	{
		TerminateProcess(tmpHandle, 0); //terminate opened process
	}
	CloseHandle(tmpHandle);
}

void PrintProcessNameAndID(DWORD processID)
{
	TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID);     

	if (NULL != hProcess)
	{
		HMODULE hMod;
		DWORD cbNeeded;

		if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
			&cbNeeded))   //extract information , Retrieves a handle for each module in the specified process
		{
			GetModuleBaseName(hProcess, hMod, szProcessName,
				sizeof(szProcessName) / sizeof(TCHAR));     //get process name and store in szprocessname
		}
	}

	_tprintf(TEXT("\n%s  (PID: %u)\n"), szProcessName, processID);

	CloseHandle(hProcess);
}

int main(int argc, TCHAR* argv[])
{
	cout << " 1: view all process\n 2: To start a new process\n 3: To terminate a process from listed\n";

	while (1)
	{
		int getOption;
		cout << "\nChoose your option : ";
		cin >> getOption;

		switch (getOption)
		{
		case 1:
		{
			DWORD aProcesses[1024], cbNeeded, cProcesses;     
			unsigned int i;
			if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))   //to get all the process ID
			{
				return 1;
			}
			cProcesses = cbNeeded / sizeof(DWORD);
			for (i = 0; i < cProcesses; i++)
			{
				if (aProcesses[i] != 0)
				{
					PrintProcessNameAndID(aProcesses[i]);    //get process name
					memoryInfor(aProcesses[i]);
				}
			}

			break;
		}
		case 2:
		{
			
			std:string s;
			cout << "Enter the process name : ";
			cin >> s;
			std::wstring ws;
			ws.assign(s.begin(), s.end());
			LPWSTR pwst = &ws[0];
			LPCWSTR pcwstr = ws.c_str();
			ShellExecute(0, L"open", pcwstr, NULL, 0, SW_SHOW);
			break;
		}
		case 3:
		{
			cout << "Enter the process ID to be deleted : ";
			DWORD processID;
			cin >> processID;
			Terminate(processID);
			break;
		}
		
		}


	}

	return 0;
}
